#ifndef __DWA__PLANNER_HPP_
#define __DWA__PLANNER_HPP_

#include <vector>
#include <Eigen/Core>

class dwa_planner {
public:
    dwa_planner();
    ~dwa_planner() = default;


    base_local_planner::Trajectory findBestPath(
        const geometry_msgs::PoseStamped& global_pose,
        const geometry_msgs::PoseStamped& global_vel,
        geometry_msgs::PoseStamped& drive_velocities);

    /**
     * @brief  Update the cost functions before planning
     * @param  global_pose The robot's current pose
     * @param  new_plan The new global plan
     * @param  footprint_spec The robot's footprint
     *
     * The obstacle cost function gets the footprint.
     * The path and goal cost functions get the global_plan
     * The alignment cost functions get a version of the global plan
     *   that is modified based on the global_pose 
     */
    void updatePlanAndLocalCosts(const geometry_msgs::PoseStamped& global_pose,
                                 const std::vector<geometry_msgs::PoseStamped>& new_plan,
                                 const std::vector<geometry_msgs::Point>& footprint_spec);

    /**
     * @brief Get the period at which the local planner is expected to run
     * @return The simulation period
     */
    double getSimPeriod() { return sim_period_; }

    /**
     * @brief Compute the components and total cost for a map grid cell
     * @param cx The x coordinate of the cell in the map grid
     * @param cy The y coordinate of the cell in the map grid
     * @param path_cost Will be set to the path distance component of the cost function
     * @param goal_cost Will be set to the goal distance component of the cost function
     * @param occ_cost Will be set to the costmap value of the cell
     * @param total_cost Will be set to the value of the overall cost function, taking into account the scaling parameters
     * @return True if the cell is traversible and therefore a legal location for the robot to move to
     */
    bool getCellCosts(int cx, int cy, float &path_cost, float &goal_cost, float &occ_cost, float &total_cost);

    /**
     * sets new plan and resets state
     */
    bool setPlan(const std::vector<geometry_msgs::PoseStamped>& orig_global_plan);

private:

    base_local_planner::LocalPlannerUtil *planner_util_;

    double stop_time_buffer_; ///< @brief How long before hitting something we're going to enforce that the robot stop
    double pdist_scale_, gdist_scale_, occdist_scale_;
    Eigen::Vector3f vsamples_;

    double sim_period_;///< @brief The number of seconds to use to compute max/min vels for dwa
    base_local_planner::Trajectory result_traj_;

    double forward_point_distance_;

    std::vector<geometry_msgs::PoseStamped> global_plan_;

    boost::mutex configuration_mutex_;
    std::string frame_id_;
    ros::Publisher traj_cloud_pub_;
    bool publish_cost_grid_pc_; ///< @brief Whether or not to build and publish a PointCloud
    bool publish_traj_pc_;

    double cheat_factor_;

    base_local_planner::MapGridVisualizer map_viz_; ///< @brief The map grid visualizer for outputting the potential field generated by the cost function

    // see constructor body for explanations
    base_local_planner::SimpleTrajectoryGenerator generator_;
    base_local_planner::OscillationCostFunction oscillation_costs_;
    base_local_planner::ObstacleCostFunction obstacle_costs_;
    base_local_planner::MapGridCostFunction path_costs_;
    base_local_planner::MapGridCostFunction goal_costs_;
    base_local_planner::MapGridCostFunction goal_front_costs_;
    base_local_planner::MapGridCostFunction alignment_costs_;
    base_local_planner::TwirlingCostFunction twirling_costs_;

    base_local_planner::SimpleScoredSamplingPlanner scored_sampling_planner_;
};
#endif
